<style>
table {
  border-collapse: collapse;
  width: 100%;
}

th, td {
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {background-color: #f2f2f2;}
</style>

<br>

# Week 7, Lecture 2, Lambda notation and the Curry-Howard isomorphism

We introduce lambda notation, a succinct notation for functions. We describe the Curry-Howard isomorphism on the implicational fragment. We gesture to how it is extended to the entire fragment of intuitionistic predicate logic, and how this is implemented in modern proof and program verification.


- [Lambda notation for functions](#lambda-notation-for-functions)
- [Functions which input and output other functions](#functions-which-input-and-output-other-functions)
- [Functional application is to arrow elimination as lambda introduction is to arrow introduction](#Functional-application-is-to-arrow-elimination-as-lambda-introduction-is-to-arrow-introduction)
- [The Curry-Howard Isomorphism](#the-curry-howard-isomorphism)
- [Proof and program verification](#proof-and-program-verification)

<br>

## Lambda notation for functions

Recall that a function $f:X\rightarrow Y$ is simply any operation which given an input $x$ from $X$ returns an output $y=f(x)$ from $Y$. In this context, $X$ is called the *domain* of the function $f$ and $Y$ is called *the codomain* of the function $f$. Here are some simple examples of functions:

- $f:\mathbb{N}\rightarrow \mathbb{N}$ given by $f(u)=2u+5$
- $g:\mathbb{Z}\rightarrow \mathbb{N}$ given by $g(v)=\left|v\right|$
- $h:\mathbb{N}\rightarrow \mathbb{Z}$ given by $h(w)=-w$

On one level, lambda notation is simply an alternative way of describing the operations associated to these functions:

- $f:\mathbb{N}\rightarrow \mathbb{N}$ is $\lambda u:\mathbb{N} . 2u+5$
- $g:\mathbb{Z}\rightarrow \mathbb{N}$ is $\lambda v: \mathbb{Z}. \left|v\right|$
- $h:\mathbb{N}\rightarrow \mathbb{Z}$ is $\lambda w:\mathbb{N}. -w$

If context supplies information about what the outputs are, we can even just redescribe these three functions as:

- $f = \lambda u:\mathbb{N} . 2u+5$
- $g = \lambda v: \mathbb{Z}. \left|v\right|$
- $h = \lambda w:\mathbb{N}. -w$

In fact, lambda notation contains enough information that you can just dispense with the labels and work directly with the lambda terms themselves.

We can illustrate this by doing some evaluations:

- $f(3)=2\cdot 3+5 =6+5=11$. Equivalently, we can write $(\lambda u:\mathbb{N} . 2u+5)(3) = 2\cdot 3+5 = 6+5=11$.
- $g(-4)=\left|-4\right|=4$. Equivalently, we can write $(\lambda v: \mathbb{Z}. \left|v\right|)(-4)= \left|-4\right|=4$.
- $h(7)=-7$. Equivalently, we can write $(\lambda w:\mathbb{N}. -w)(7) = -7$.

The general form of a lambda term is $\lambda x: X . L$, where $L$ is an expression for an operation which features free input variable $x$ from domain $X$ and where the corresponding output is of type $Y$. The lambda term $\lambda x: X . L$ then denotes a function from $X$ to $Y$. In our three examples, the $L$'s were respectively:

- $2u+5$
- $\left|v\right|$
- $-w$

Since it denotes a function, whenever you have an input $a$ from $X$, you can evaluate $(\lambda x: X . L)a$ by replacing all free instances of $x$ in by $a$. In more formal treatments of the lambda-calculus, such a single application of replacement is called a $\beta$-reduction. That's what we were doing in our simple evaluation examples.

<br>

## Functions which input and output other functions

Part of the beauty of the lambda notation for functions is that it gives a succinct way of describing the action of functions on other functions. For instance, suppose we are interested in functions from natural numbers to integers. Given any such function $f:\mathbb{N}\rightarrow \mathbb{Z}$, we can build another function by further subtracting 5. That is, we could consider the function $g:\mathbb{N}\rightarrow \mathbb{Z}$ given by $g(v) = f(v)-5$. This operation of "further substract 5" takes $f:\mathbb{N}\rightarrow \mathbb{Z}$ to $g:\mathbb{N}\rightarrow \mathbb{Z}$ is also a function, namely a function from functions to functions. We can denote it in lambda notation as follows:

- $\lambda f:\mathbb{N}\rightarrow \mathbb{Z} . \lambda v:\mathbb{N} . f(v)-5$.

Call this function $H$, for short. There are two lambda expressions in our notation for $H$. It is saying that if you feed $H$ an input of a function $f:\mathbb{N}\rightarrow \mathbb{Z}$, you get the output $\lambda v:\mathbb{N} . f(v)-5$. And this output is itself a function. We say that $H:(\mathbb{N}\rightarrow \mathbb{Z})\rightarrow (\mathbb{N}\rightarrow \mathbb{Z})$ since it takes functions $f:\mathbb{N}\rightarrow \mathbb{Z}$ as input and outputs functions $g:\mathbb{N}\rightarrow \mathbb{Z}$. (If you like to think in terms of sets, the domain of $H$ is the set of all functions from $\mathbb{N}$ to $\mathbb{Z}$, and its codomain is likewise the set of all functions from $\mathbb{N}$ to $\mathbb{Z}$.)

To take another example, suppose that $f:\mathbb{N}\rightarrow \mathbb{N}$ is a function, and we want to consider the function $g(v)=f(f(f(v)))$, that is "apply $f" three times. This "apply three times" operation is an operation which takes functions $f:\mathbb{N}\rightarrow \mathbb{N}$ as inputs and outputs functions $g:\mathbb{N}\rightarrow \mathbb{N}$. We can denote the "apply three times" function in lambda notation as follows:

- $\lambda f:\mathbb{N}\rightarrow \mathbb{Z} . \lambda v:\mathbb{N} . f(f(f(v)))$.

Call this function $J$, for short. There are two lambda expressions in our notation for $J$. It is saying that if you feed $J$ an input of a function $f:\mathbb{N}\rightarrow \mathbb{N}$, you get the output $ \lambda v:\mathbb{N} . f(f(f(v)))$. And this output is itself a function. We say that $J:(\mathbb{N}\rightarrow \mathbb{N})\rightarrow (\mathbb{N}\rightarrow \mathbb{N})$ since it takes functions $f:\mathbb{N}\rightarrow \mathbb{N}$ as input and outputs functions $g:\mathbb{N}\rightarrow \mathbb{N}$.


<br>

## Functional application is to arrow elimination as lambda introduction is to arrow introduction

The *first* observation is that functional application looks a lot like an application of arrow elmination (or modus ponens), perhaps supplemented by the arrow clauses of Tarski's definition of truth in a model:

- If $f:X\rightarrow Y$ and $c$ is in $X$, then $f(c)$ is in $Y$.
- If $\phi\rightarrow \psi$ is true and $\phi$ is true, then $\psi$ is true.

Presumably the sense of "true" in the second is something like "true in the model," where the relevant model is determined by context. If we want to further deemphasize the semantic notions, we can we could just remove "is true" and it seems to have the same sense. Likewise, if we want to demphasize the set-theoretic notions in the first of these, we can write $x:X$ instead of "$x$ is in $X$", and we can write $f(x):Y$ instead of "$f(x)$ is in $Y$". If we rewrite in this way, we get two rules which are more ostensibly bereft of semantic and set-theoretic notions, and where the second is literally arrow elimination:

- If $f:X\rightarrow Y$ and $c:X$, then $f(c):Y$.
- If $\phi\rightarrow \psi$ and $\phi$, then $\psi$.

The *second* observation is that a natural way to introduce lambda terms looks a lot like arrow introduction, again perhaps in some partially thematized semantic setting:

- If from the supposition that $x$ in $X$ it follows that $\psi$ in $Y$, then $f=\lambda x : X . \psi$ is a function $f:X\rightarrow Y$.
- If from the supposition of $\phi$ being true one can infer that $\psi$ is true, then $\phi\rightarrow \psi$ is true.

In the first, the $\psi$ is just supposed to be some expression in which $x$ is paradigmatically free, and wherelike above, $\psi$ returns a value in $Y$ when given a specific value of $x$ in $X$. If we remove set theory and the semantics as above, we get the following, where the second is literally just arrow introduction:

- If from $x:X$ it follows that $\psi: Y$, then $(\lambda x : X . \xi) : X\rightarrow Y$
- If from $\phi$ it follows that $\psi$, then $(\phi\rightarrow \psi)$.

Just as we allow ourselves to drop outer parentheses in logic, so we do when dealing with lambda terms. Hence we can rewrite this pair one more time as:

- If from $x:X$ it follows that $\psi: Y$, then $\lambda x : X . \xi \; : X\rightarrow Y$
- If from $\phi$ it follows that $\psi$, then $\phi\rightarrow \psi$.

We can summarize these two observations in the following diagram:




These are lecture notes written by Sean Walsh. They are run on [carnap.io](http://www.carnap.io).[^7]

[^7]: which is:
