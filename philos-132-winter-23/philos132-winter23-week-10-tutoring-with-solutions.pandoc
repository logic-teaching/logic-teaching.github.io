<style>
table {
  border-collapse: collapse;
  width: 100%;
}

th, td {
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {background-color: #f2f2f2;}
</style>

<br>

# Week 10 Tutoring with solutions

- [Famous Proofs](#famous-proofs)
- [Proof or countermodel](#proof-or-countermodel)
- [Week 6 problems](#week-6-problems)
- [Week 7 problems](#week-7-problems)
- [Week 8 problems](#week-8-problems)
- [Week 9 problems](#week-9-problems)
- [Summary of rules of classical predicate logic](#summary-of-rules-of-classical-predicate-logic)

We practice for the final exam.

- [Famous Proofs](#famous-proofs)
- [Proof or countermodel](#proof-or-countermodel)
- [Week 6 problems](#week-6-problems)
- [Week 7 problems](#week-7-problems)
- [Week 8 problems](#week-8-problems)
- [Week 9 problems](#week-9-problems)
- [Summary of rules of classical predicate logic](#summary-of-rules-of-classical-predicate-logic)

This is practice for the final. In particular, it is practice with parts I, II, III of the final.

- It is *strongly advised* that you work it out by hand, since that it what we will be doing on the final.

- And again, the reason we are doing this is because the aim of the second half of this course is for you to learn to write proofs, with the goal of being able to do so without the aid of a proof checker, since there no proof checkers in later parts of logic or in later applications of logic.

- You can check your answers by looking at this solution document, or by typing your answers directly into the version without solutions.

- The formatting of this page may look a little different, but that is because it is designed to be printed.

- Keep in mind that there are many good proofs of one and the same result, and keep in mind that partial credit will be available on the proofs in the final.

<br>

<p style="page-break-before: always">

## Famous proofs

<br>

*Problem 1*

Give the famous proof of Russell's paradox in intuitionistic logic from [Week 7 Section](https://carnap.io/shared/logiclogiclogic/philos132-winter23-week-07-section-with-solutions.pandoc) Problem 3.

For this problem, use only the introduction and elimination rules, along with ex falso and repeat rule. That is, this proof is a proof in intuitionistic predicate logic.

```{.ProofChecker .GamutNDPlus submission="none" }
10.01 :|-: ~(Ax((Rxc/\Txc)->~(Rxx/\Txx))/\Ax(~(Rxx/\Txx)->(Rxc/\Txc)))
| (Ax((Rxc/\Txc)->~(Rxx/\Txx))/\Ax(~(Rxx/\Txx)->(Rxc/\Txc))) :as
| Ax((Rxc/\Txc)->~(Rxx/\Txx)) :E/\1
| Ax(~(Rxx/\Txx)->(Rxc/\Txc)) :E/\1
| (Rcc/\Tcc)->~(Rcc/\Tcc) :EA2
| ~(Rcc/\Tcc)->(Rcc/\Tcc) :EA3
|  (Rcc/\Tcc) :as
|  ~(Rcc/\Tcc) :E->4,6
|  !? :E~6,7
| ~(Rcc/\Tcc) :I~6-8
| (Rcc/\Tcc) :E->5,9
| !? :E~9,10
|~(Ax((Rxc/\Txc)->~(Rxx/\Txx))/\Ax(~(Rxx/\Txx)->(Rxc/\Txc))) :I~1-11
```

<br>

<p style="page-break-before: always">

*Problem 2*

This is the famous proof that intuitionistic logic proves the one non-trivial validity involving multiple quantifiers (From [Week 7, Section](https://carnap.io/shared/logiclogiclogic/philos132-winter23-week-07-section-with-solutions.pandoc) Problem 5).

For this problem, use only the introduction and elimination rules, along with ex falso and repeat rule. That is, this proof is a proof in intuitionistic predicate logic.

```{.ProofChecker .GamutNDPlus submission="none" }
10.02 EyAx(Rxy\/Txy)  :|-: AxEy(Rxy\/Txy)
|EyAx(Rxy\/Txy) :assumption
| Ax(Rxb\/Txb) :assumption
| (Rab\/Tab) :EA2
| Ey(Ray\/Tay) :IE3
| AxEy(Rxy\/Txy) :IA4
|Ax(Rxb\/Txb) ->AxEy(Rxy\/Txy) :I->2-5
|AxEy(Rxy\/Txy) :EE1,6
```

<br>

<p style="page-break-before: always">

## Proof or countermodel

<br>

*Problem 3*

```{.ProofChecker .GamutNDPlus submission="none"}
10.03 Ax(Gx->Hx), Fa, Ga :|-: Ax((Fx->Gx)->Hx)
|Ax(Gx->Hx) :assumption
|Fa :assumption
|Ga :assumption
```

<br>

<br>

<br>

<br>

```{.CounterModeler .Validity system="gamutND" submission="none" options="negated-double-turnstile"}
10.03 Ax(Gx->Hx), Fa, Ga :|-: Ax((Fx->Gx)->Hx)
|Domain: 0,1,2,3
|F(_):0
|G(_):0,1
|H(_):0,1,2
|a:0
```

<br>

<p style="page-break-before: always">

*Problem 4*

The first three axioms are the axioms of [equivalence relations](https://carnap.io/shared/logiclogiclogic/philos132-winter23-week-04-tutoring-with-solutions.pandoc#validity-and-invalidity-with-orders-and-equivalence-relations). The basic idea is that an equivalence relation is a notion of similarity among objects which acts like identity in a lot of ways: I am similar to myself (reflexivity), if I am similar to you, then you are similar to me (symmetry), if I am similar to you, and you are simliar to a third person, then I am similar to this third person (transitivity). Hence, use your intuitions about similarity to help guide you through the problems. Another fact about equivalence relations to keep in mind is: they partition the domain into disjoint classes (called equivalence classes). For instance, assuming double-majors are not allowed, then "sameness of major" would partition the students into disjoint groups, namely the majors.

```{.ProofChecker .GamutNDPlus submission="none"}
10.04 AxRxx, AxAy(Rxy->Ryx), AxAyAz((Rxy/\Ryz)->Rxz), Rab, Rcb, Rcd :|-: Rad
|AxRxx :as
|AxAy(Rxy->Ryx) :as
|AxAyAz((Rxy/\Ryz)->Rxz) :as
|Rab :as
|Rcb :as
|Rcd :as
|Ay(Rcy->Ryc) :EA2
|Rcb->Rbc :EA7
|Rbc :E->5,8
|Rab/\Rbc :I/\4,9
|AyAz((Ray/\Ryz)->Raz) :EA3
|Az((Rab/\Rbz)->Raz) :EA11
|(Rab/\Rbc)->Rac :EA12
|Rac :E->10,13
|Rac/\Rcd :I/\6,14
|AyAz((Ray/\Ryz)->Raz) :EA3
|Az((Rac/\Rcz)->Raz) :EA16
|(Rac/\Rcd)->Rad :EA17
|Rad :E->15,18
```

<br>

<br>

<br>

<br>

```{.CounterModeler .Validity system="gamutND" submission="none" options="negated-double-turnstile"}
10.04 AxRxx, AxAy(Rxy->Ryx), AxAyAz((Rxy/\Ryz)->Rxz), Rab, Rcb, Rcd :|-: Rad
|Domain:
|R(_,_):
|a:
|b:
|c:
|d:
```

<br>

<p style="page-break-before: always">

*Problem 5*

```{.ProofChecker .GamutNDPlus submission="none"}
10.05 AxEy(Rxy/\Gy), AxEz(Rxz/\Hz), Rab/\Gb, Rac/\~Gc :|-: AxEyEz((Rxy/\Rxz)/\~y=z)
|AxEy(Rxy/\Gy) :assumption
|AxEz(Rxz/\Hz) :assumption
|Rab/\Gb :assumption
|Rab/\~Gc :assumption
```

<br>

<br>

<br>

<br>

```{.CounterModeler .Validity system="gamutND" submission="none" options="negated-double-turnstile"}
10.05 AxEy(Rxy/\Gy), AxEz(Rxz/\Hz), Rab/\Gb, Rac/\~Gc :|-: AxEyEz((Rxy/\Rxz)/\~y=z)
|Domain: 0,1,2
|G(_): 0,1
|H(_): 0,2
|R(_,_): [0,1], [0,2], [1,0], [2,0]
|a:0
|b:1
|c:2
```

<br>

<p style="page-break-before: always">

*Problem 6*

<br>

The first four axioms are the axioms of [linear orders](https://carnap.io/shared/logiclogiclogic/philos132-winter23-week-04-tutoring-with-solutions.pandoc#validity-and-invalidity-with-orders-and-equivalence-relations). These are axioms that describe $\leq$ on the natural numbers, integers, and rationals. The linearity axiom (the fourth axiom) says that given $x,y$ one either has $x\leq y$ or $y\leq x$ or $x=y$. Use your intuitions about lines to guide yourself through the problem.

```{.ProofChecker .GamutNDPlus submission="none"}
10.06 AxRxx, AxAy((Rxy/\Ryx)->x=y), AxAyAz((Rxy/\Ryz)->Rxz), AxAy((Rxy\/Ryx)\/x=y), ~Rab, ~a=b  :|-: Rba
|AxRxx :assumption
|AxAy((Rxy/\Ryx)->x=y) :assumption
|AxAyAz((Rxy/\Ryz)->Rxz) :assumption
|AxAy((Rxy\/Ryx)\/x=y) :assumption
|~Rab :assumption
|~a=b :assumption
|Ay((Ray\/Rya)\/a=y) :EA4
|(Rab\/Rba)\/a=b :EA7
|a=b\/(Rab\/Rba) :LCD8
|Rab\/Rba :PDS 6,9
|Rba :PDS 5,10
```

<br>

<br>

<br>

<br>

```{.CounterModeler .Validity system="gamutND" submission="none" options="negated-double-turnstile"}
10.06  AxRxx, AxAy((Rxy/\Ryx)->x=y), AxAyAz((Rxy/\Ryz)->Rxz), AxAy((Rxy\/Ryx)\/x=y), ~Rab, ~a=b  :|-: Rba
|Domain:
|R(_,_):
|a:
|b:
|c:
```

<br>

<p style="page-break-before: always">

## Week 6 problems

<br>

For these problems, use only the introduction and elimination rules, along with ex falso and repeat rule. That is, these proofs are proofs in intuitionistic predicate logic.

<br>

*Problem 7*

For this problem, try to organize it so that the first new line is `EyRay` and the second to last line is `Raa`. Then try to eliminate this existential by getting a line that says `Rab->Raa`.

```{.ProofChecker .GamutNDPlus submission="none" }
10.07 AxAy(Rxy->Rxx), AxEyRxy :|-: AxRxx
|AxAy(Rxy->Rxx) :assumption
|AxEyRxy :assumption
|EyRay :EA2
| Rab :assumption
| Ay(Ray->Raa) :EA1
| Rab->Raa :EA5
| Raa :E->4,6
|Rab->Raa :I->4-7
|Raa :EE3,8
|AxRxx :IA9
```

<br>

<p style="page-break-before: always">

*Problem 8*

Prove the following in intuitionistic logic, i.e. using only the introduction and elimination rule, plus ex falso and repeat. (This is a minor variation on the Fourth Conversion).

```{.ProofChecker .GamutND submission="none"}
10.08 Ax(Fx->Gx), Ex(Fx/\Hx) :|-: Ex(Gx/\Fx)
|Ax(Fx->Gx) :assumption
|Ex(Fx/\Hx) :assumption
| Fc/\Hc :assumption
| Fc :E/\3
| Fc->Gc :EA1
| Gc :E->4,5
| Gc/\Fc :I/\4,6
| Ex(Gx/\Fx) :IE7
|(Fc/\Hc)->Ex(Gx/\Fx) :I->3-8
|Ex(Gx/\Fx) :EE2,9
```


<br>

<p style="page-break-before: always">

*Problem 9*

For this one, solve it using the Aristotelian syllogisms (which we showed were all derivable in intuitionistic predicate logic). For reference, we recopy the Aristotelian syllogisms here.

<table style="width:120%">
  <tr>
    <th>Name</th>
    <th>Typed</th>
    <th>Validity</th>
  </tr>
  <tr>
    <td>First Conversion</td>
    <td>`CV1`</td>
    <td>$\exists \; x \; (Fx\wedge Gx)\vdash \exists \; x \; (Gx\wedge Fx)$</td>
  </tr>
    <td>Second Conversion</td>
    <td>`CV2`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx) \vdash \neg \exists \; x \; (Gx\wedge Fx)$</td>
  <tr>
    <td>Third Conversion</td>
    <td>`CV3`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx) \vdash \forall \; x\; (Fx\rightarrow \neg Gx)$</td>
  </tr>
    <td>Fourth Conversion (with Existential Premise)</td>
    <td>`CV4`</td>
    <td>$\forall \; x \; (Fx\rightarrow Gx), \exists \; x \; Fx \vdash \exists \; x \; (Fx\wedge Gx)$</td>
  <tr>
    <td>Barbara</td>
    <td>`Ba`</td>
    <td>$\forall \; x \; (Fx\rightarrow Gx), \forall \; x \; (Gx\rightarrow Hx) \vdash \forall \; x \; (Fx\rightarrow Hx)$</td>
  </tr>
  <tr>
    <td>Celarent</td>
    <td>`Ce`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx), \forall \; x \; (Hx\rightarrow Fx) \vdash \neg \exists \; x \; (Hx\wedge Gx)$</td>
  <tr>
    <td>Darii</td>
    <td>`Da`</td>
    <td>$\forall \; x \; (Fx\rightarrow Gx), \exists \; x \; (Hx \wedge Fx) \vdash \exists \; x \; (Hx \wedge Gx)$</td>
  </tr>
  <tr>
    <td>Ferio</td>
    <td>`Fe`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx), \exists \; x \; (Hx\wedge Fx) \vdash \exists \; x \; (Hx\wedge \neg Gx)$</td>
  </tr>
</table>

<br>

```{.ProofChecker .GamutNDPlus submission="none" }
10.09 ~Ex(Rax/\Rbx), Ax(Rcx->Rbx) :|-: ~Ex(Rcx/\Rax)
|~Ex(Rax/\Rbx) :assumption
|Ax(Rcx->Rbx) :assumption
|~Ex(Rbx/\Rax) :CV2 1
|~Ex(Rcx/\Rax) :Ce 2,3
```

<br>

<p style="page-break-before: always">

## Week 7 problems

<br>

*Problem 10*

For this problem, use only the introduction and elimination rules, along with ex falso and repeat rule. That is, this proof is a proof in intuitionistic predicate logic.

This problem is an exercise in ex falso.

```{.ProofChecker .GamutND submission="none"}
10.10 Ax((Fx->Gx)->Hx), Ax~Fx :|-: AxHx
|Ax((Fx->Gx)->Hx) :assumption
|Ax~Fx :assumption
|(Fa->Ga)->Ha :EA1
| Fa :assumption
| ~Fa :EA2
| !? :E~4,5
| Ga :EFSQ 6
|Fa->Ga :I->4-7
|Ha :E->3,8
|AxHx :IA9
```

<br>

<p style="page-break-before: always">

*Problem 11*

Consider the following proof in the implicational fragment of intuitionistic propositional logic:

```{.ProofChecker .GamutMPND submission="none"}
 :|-: p->(q->(((r->q)->(p->s))->s))
| p :as
|  q :as
|   (r->q)->(p->s) :as
|    r :as
|    q :rep 2
|   r->q :I->4-5
|   p->s :E->3,6
|   s :E->1,7
|  ((r->q)->(p->s))->s :I->
| q->(((r->q)->(p->s))->s) :I->
|p->(q->(((r->q)->(p->s))->s)) :I->
```

<br>

Suppose that you decorate the first four assumptions with $u:p$, $v:q$, $f:(r\rightarrow q)\rightarrow (p\rightarrow s)$, and $w:r$. After decorating the rest of the proof, what lambda term do you get? *Hint*: you may need to recopy the above proof and add the lambda terms as you go. There are some extra blank pages below which give you space to do that. The introduction and elimination rules for arrow in the lambda calculus are also recopied for reference in the next pages. *Hint*: after getting your answer by decorating, you can "check it" by making sure that the inputs match the domains of the functions in question.

```{.QualitativeProblem .MultipleChoice options="check" submission="none"}
10.11 After decorating the rest of the proof, what lambda term do you get on the last line?
| λu:p λv:q λf:(r->q)->(p->s) . f(λw:r . u) v
| λu:p λv:q λf:(r->q)->(p->s) . f(u) f(v) f(w)
|+ λu:p λv:q λf:(r->q)->(p->s) . f(λw:r . v) u
| λu:p λv:q λf:(r->q)->(p->s) λw:r. f(v) u(w)
```

<br>

<p style="page-break-before: always">

[extra page for scratch work for previous problem]



<p style="page-break-before: always">

This page is *merely* for reference, and includes the introduction and elimination rules for arrow for our lambda calculus:

Elimination rules for arrow:

- *Lambda calculus*: If $M:P\rightarrow Q$ and $N:P$, then $MN:Q$.

- *Logic*: If $P\rightarrow Q$ and $P$, then $Q$.

We can write these two rules side by side in our more familiar proof format as follows:

&nbsp; &nbsp; &nbsp;  <img src="https://logic-teaching.github.io/philos-132-winter-23/texts/lambda-calculus-elim-rules-2.png" alt="Elimination rules" width="800"/>

<br>

Introduction rules for arrow:

- *Lambda calculus*: If from $x:P$ it follows that $M: Q$, then $\lambda x : P .\; M\; : P\rightarrow Q$

- *Logic*: If from $P$ it follows that $Q$, then $P\rightarrow Q$.

We can write these two rules side by side in our more familiar proof format as follows:

&nbsp; &nbsp; &nbsp;  <img src="https://logic-teaching.github.io/philos-132-winter-23/texts/lambda-calculus-intro-rules-2.png" alt="Elimination rules" width="800"/>

<p style="page-break-before: always">

*Problem 12*

This is a problem in inferring types. *Hint*: figure out what type $(f(g))(-5)$ has.

```{.QualitativeProblem .MultipleChoice options="check" submission="none"}
10.12 What is the type of λf : (ℤ->ℚ)->(ℤ->ℚ)  λg : ℤ->ℚ . (f(g))(-5) ?
| ((ℤ->ℚ)->ℚ)->((ℤ->ℚ)->(ℤ->ℚ))
| ((ℤ->ℚ)->(ℤ->ℚ))->(ℚ->(ℤ->ℚ))
| ((ℤ->ℚ)->(ℤ->ℚ))->(ℚ->(ℤ->ℚ))
|+ ((ℤ->ℚ)->(ℤ->ℚ))->((ℤ->ℚ)->ℚ)
```

<br>

<p style="page-break-before: always">

## Week 8 problems

<br>

For these problems, one can use any of the rules of classical predicate logic. See [Summary of rules of classical predicate logic](#summary-of-rules-of-classical-predicate-logic) for reference.

<br>

*Problem 13*

While this problem can be solved in many ways, it has one comparatively simple proof which features prominently the a disjunctive syllogism and DeMorgan.

```{.ProofChecker .GamutNDPlus submission="none"}
10.13 ~(ExGx/\ExFx), Gb, Ax(Hx->Fx) :|-: Ax~Hx
|~(ExGx/\ExFx) :assumption
|Gb :assumption
|Ax(Hx->Fx) :assumption
|ExGx :IE2
|~ExFx :NDS 1,4
|Ax~Fx :DMALL5
|~Fa :EA6
|Ha->Fa :EA3
|~Fa->~Ha :CP 8
|~Ha :E->7,9
|Ax~Hx :IA10
```

<br>

<p style="page-break-before: always">

*Problem 14*

This is a version of Pierce's law, a statement about arrows which is only provable in classical logic. While there are many proofs of it, one simple one treats it like a normal arrow statement going from `((Rac->Rbc)->Rac)` to `Rac` in a bracket, and derives the last line of the bracket `Rac` from `~~Rac` via double-negation.

```{.ProofChecker .GamutNDPlus submission="none"}
10.14  :|-: ((Rac->Rbc)->Rac)->Rac
Ax(x=a\/x=b) :assumption
c=a\/c=b :assumption
 c=a :assumption
 a=a :I=
 a=c :E=3,4
 a=c\/b=c :I\/5
c=a->(a=c\/b=c) :I->3-6
 c=b :assumption
 b=b :I=
 b=c :E= 8,9
 a=c\/b=c :I\/10
c=b->(a=c\/b=c) :I->8-11
a=c\/b=c :E\/2,7,12
```

<br>

<p style="page-break-before: always">

*Problem 15*

Give a resolution proof of

$\forall \; x \; \forall \; y \; (Rxy\rightarrow Ryx), \forall \; x \forall \; y \; \forall \; z \; ((Rxy\wedge Ryz)\rightarrow Rxz), Rba, Rbc \vdash Rac$

&nbsp; &nbsp; &nbsp;  <img src="https://logic-teaching.github.io/philos-132-winter-23/texts/resolution-example-10.png" alt="Resolution example" width="800"/>

<br>

<p style="page-break-before: always">

## Week 9 problems

<br>

*Problem 16*

Consider the statement $\exists \; x \; Fx \wedge \exists \; x \; Gx \nvdash \exists \;x \;(Fx\wedge Gx)$.

```{.QualitativeProblem .MultipleChoice options="check" submission="none"}
10.16 What is this a claim about?
| Some proofs
|+ All proofs
| Some models
| All models
```

<br>

<p style="page-break-before: always">

*Problem 17*

This problem has two parts, where we use the key:

| F = French major
| G = Geography major
| a = Ashley

~~~{.Translate .Exact system="gamutNDSOL" submission="none"}
10.17.1 (Fa/\~Ga)->Ex(Fx/\~Gx) : If Ashley is a French major but not a Geography major, then someone is a French major but not a Geography major.
|(Fa/\~Ga)->Ex(Fx/\~Gx)
~~~

<br>

<br>

<br>


<br>

~~~{.Translate .Exact system="gamutNDSOL" submission="none"}
10.17.2 (Fa/\~Ga)->EX1(X1a/\~Ey(X1y/\Gy)), (Fa/\~Ga)->EX1(X1a/\~Ey(Gy/\X1y)), (Fa/\~Ga)->EX1(X1a/\Ay(X1y->~Gy)), (Fa/\~Ga)->EX1(X1a/\Ay(Gy->~X1y)) : If Ashley is a French major but not a Geography major, then Ashley has some property which no Geography major has.
|(Fa/\~Ga)->EX1(X1a/\~Ey(X1y/\Gy))
~~~

<br>

<p style="page-break-before: always">

*Problem 18*

This is a problem in the deductive system for second-order logic. For reference, we recopy the rules  on the next page.

Note that this is an instance of the comprehension schema, and hence is evidence that our lambda terms do indeed provide enough names for the properties to validiate the comprehension schema.

```{.ProofChecker .GamutNDSOL submission="none"}
10.18 :|-: EX1Ax(((Fx/\Gx)->X1x)/\(X1x->(Fx/\Gx)))
| (Fa/\Ga) :assumption
| \y[(Fy/\Gy)]a :ABS1 1
|(Fa/\Ga)->\y[(Fy/\Gy)]a :I->1-2
| \y[(Fy/\Gy)]a :assumption
| (Fa/\Ga) :APP1 4
|\y[(Fy/\Gy)]a->(Fa/\Ga) :I->4-5
|((Fa/\Ga)->\y[(Fy/\Gy)]a)/\(\y[(Fy/\Gy)]a->(Fa/\Ga)) :I/\3,6
|Ax(((Fx/\Gx)->\y[(Fy/\Gy)]x)/\(\y[(Fy/\Gy)]x->(Fx/\Gx))) :IA 7
|EX1Ax(((Fx/\Gx)->X1x)/\(X1x->(Fx/\Gx))) :IE1 8
```



<p style="page-break-before: always">

These are the rules for our second-order deductive system. They are included only for reference.

<table style="width:125%">
  <tr>
    <th>Name</th>
    <th>Rule</th>
    <th>Rule, typed</th>
    <th>Abbreviation</th>
  </tr>
  <tr>
    <td>Application</td>
    <td>$\lambda x. [ϕ(x)]a \vdash ϕ(a)$</td>
    <td>`\x[ϕ(x)]a ⊢ ϕ(a)` or `λx[ϕ(x)]a ⊢ ϕ(a)` </td>
    <td>`APP1`</td>
  </tr>
  <tr>
    <td>Abstraction</td>
    <td>$ϕ(a) \vdash \lambda x. [ϕ(x)]a$</td>
    <td>`ϕ(a) ⊢ \x[ϕ(x)]a` or `ϕ(a) ⊢ λx[ϕ(x)]a` </td>
    <td>`ABS1`</td>
  </tr>
  <tr>
    <td>Introduction of second-order existential</td>
    <td>$\psi(\lambda x. [ϕ(x)]) \ldots \vdash \exists \; X \; \psi(X)$</td>
    <td>`ψ(\x[ϕ(x)]) ⊢ EX1 ψ(X1)` or `ψ(λx[ϕ(x)]) ⊢ EX1 ψ(X1)` </td>
    <td>`IE1`</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>or `ψ(λx[ϕ(x)]) ⊢ EX1 ψ(X1)` </td>
    <td>
  </tr>
  <tr>
    <td>Elimination of second-order universal</td>
    <td>$\forall \; X \; \psi(X) \vdash \psi(\lambda x. [ϕ(x)])$</td>
    <td>`AX1 ψ(X1) ⊢ ψ(\x[ϕ(x)])` or `AX1 ψ(X1) ⊢ ψ(λx[ϕ(x)])` </td>
    <td>`EA1`</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>or `AX1 ψ(X1) ⊢ ψ(λx[ϕ(x)])` </td>
    <td></td>
  </tr>
  <tr>
    <td>Introduction of second-order universal</td>
    <td>$\psi(Y) \vdash \forall \; X \; \psi(X)$</td>
    <td>`ψ(Y1) ⊢ AX1 ψ(X1)` </td>
    <td>`IA1`</td>
  </tr>
  <tr>
    <td>Elimination of second-order existential</td>
    <td>$\exists \; X \; \psi(X), \psi(Y)\rightarrow \xi \vdash \xi$</td>
    <td>`EX1 ψ(X1), ψ(Y1)->ξ ⊢ ξ` </td>
    <td>`EE1`</td>
  </tr>
</table>

<br>

<p style="page-break-before: always">

[blank page for scratch work]

<p style="page-break-before: always">

[blank page for scratch work]

<p style="page-break-before: always">

<p style="page-break-before: always">

[blank page for scratch work]

<p style="page-break-before: always">

[blank page for scratch work]

<br>

<p style="page-break-before: always">

## Summary of rules of classical predicate logic

For reference, here is a summary of all the rules available in our system of classical predicate logic, i.e. the Week 8 system.

<table style="width:100%">
  <tr>
    <th>Rule</th>
    <th>Abbreviation</th>
    <th>Statement</th>
  </tr>
  <tr>
    <td>Law of excluded middle</td>
    <td>`LEM`</td>
    <td>$\phi\vee \neg \phi$</td>
  </tr>
  <tr>
    <td>The law of double-negation</td>
    <td>`DN`</td>
    <td>$\phi$ is equivalent to $\neg \neg \phi$</td>
  </tr>
  <tr>
    <td>Law of non-contradiction</td>
    <td>`LNC`</td>
    <td>$\neg (\phi\wedge \neg \phi)$</td>
  </tr>
 <tr>
    <td>DeMorgan</td>
    <td>`DMSOME`</td>
    <td>$\neg \forall \; x \; \phi(x)$ is equivalent to $\exists \; x \; \neg \phi(x)$</td>
  </tr>
  <tr>
    <td>DeMorgan</td>
    <td>`DMALL`</td>
    <td>$\neg \exists \; x \; \phi(x)$ is equivalent to $\forall \; x \; \neg \phi(x)$</td>
  </tr>
  <tr>
    <td>DeMorgan</td>
    <td>`DMOR`</td>
    <td>$\neg (\phi\wedge \psi)$ is equivalent to $\neg \phi \vee \neg \psi$</td>
  </tr>
  <tr>
    <td>DeMorgan</td>
    <td>`DMAND`</td>
    <td>$\neg (\phi\vee \psi)$ is equivalent to $\neg \phi \wedge \neg \psi$</td>
  </tr>
 <tr>
    <td>(Positive) Disjunctive syllogism</td>
    <td>`PDS`</td>
    <td>$\phi\vee \psi, \neg \phi \vdash \psi$</td>
  </tr>
  <tr>
    <td>(Negative) disjunctive syllogism</td>
    <td>`NDS`</td>
    <td>$\neg (\phi\wedge \psi), \phi \vdash \neg \psi$</td>
  </tr>
  <tr>
    <td>Negated conditionals and conjunctive statements</td>
    <td>`NC`</td>
    <td>$\neg (\phi \rightarrow \psi)$ is equivalent to $\phi \wedge \neg \psi$</td>
  </tr>
  <tr>
    <td>Conditionals and disjunctive statements</td>
    <td>`DC`</td>
    <td>$\phi\rightarrow \psi$ is equivalent to $\neg \phi \vee \psi$</td>
  </tr>
  <tr>
    <td>Contraposition</td>
    <td>`CP`</td>
    <td>$\phi\rightarrow \psi$ is equivalent to $\neg \psi\rightarrow \neg \phi$</td>
  </tr>
  <tr>
    <td>Modus tollens</td>
    <td>`MT`</td>
    <td>$\phi\rightarrow \psi, \neg \psi \vdash \neg \phi$</td>
  </tr>
  <tr>
    <td>Law of commutativity for conjunction</td>
    <td>`LCC`</td>
    <td>$\phi\wedge \psi$ is equivalent to $\psi\wedge \phi$</td>
  </tr>
  <tr>
    <td>Law of commutativity for disjunction</td>
    <td>`LCD`</td>
    <td>$\phi\vee \psi$ is equivalent to $\psi\vee \phi$</td>
  </tr>
  <tr>
    <td>Law of associativity for conjunction</td>
    <td>`LAC`</td>
    <td> $(\phi\wedge \psi)\wedge \xi$ is equivalent to $\phi\wedge (\psi\wedge \xi)$</td>
  </tr>
  <tr>
    <td>Law of associativity for disjunction</td>
    <td>`LAD`</td>
    <td>$(\phi\vee \psi)\vee \xi$ is equivalent to $\phi\vee (\psi\vee \xi)$</td>
  </tr>
  <tr>
    <td>Law of distribution for conjunction</td>
    <td>`LDC`</td>
    <td>$\phi\wedge (\psi\vee \xi)$ is equivalent to $(\phi\wedge \psi)\vee (\phi\wedge \xi)$</td>
  </tr>
  <tr>
    <td>Law of distribution for disjunction</td>
    <td>`LDD`</td>
    <td>$\phi\vee (\psi\wedge \xi)$ is equivalent to $(\phi\vee \psi)\wedge (\phi\vee \xi)$</td>
  </tr>
 <tr>
    <td>Introduction rule for identity</td>
    <td>`I=`</td>
    <td>$a=a$</td>
  </tr>
  <tr>
    <td>Elimination rule for identity</td>
    <td>`E=`</td>
    <td> $a=b, \phi(a) \vdash \phi(b)$</td>
  </tr>
  <tr>
    <td>Introduction rule for $\iota$</td>
    <td>`Ii`</td>
    <td>$\exists \; x \; (Fx\wedge \forall \; y \; (Fy\rightarrow y=x))\vdash F\iota x Fx$</td>
  </tr>
  <tr>
    <td>Elimination rule for $\iota$</td>
    <td>`Ei`</td>
    <td>$\iota x Fx\neq \iota x \bot \vdash \exists \; x \; (Fx\wedge \forall \; y \; (Fy\rightarrow y=x))$</td>
  </tr>
</table>

<br>arrow y=x))$</td>
  </tr>
</table>

<br>
